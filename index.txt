include::/tmp/t.ad[]

+++ <small> +++

* Repo: httpx://github.com/lvv/sto[GitHub],  httpx://bitbucket.org/lvv/sto[BitBucket] +
* Requires:  +++ C++11 +++   compiler.  Tested with GCC-4.7.2, GCC-4.8(pre release), CLANG-3.2(pre release) +
* License:  httpx://en.wikipedia.org/wiki/Boost_Software_License[Boost Software License]

+++ </small> +++


SCC
---

STO was originally part of SCC (+++ C++ +++ snippet evaluator at shell prompt).
It does not depands on SCC but we will use it in examples, so we need to
tell about SCC first.  Without SCC, minimal complete example for 
`operator*(Range,Functor)` would be:

----------------------------------------------------------------------------
#include <iostream>
#include <string>
	using namespace std;

#include <sto/sto.h>
	using namespace sto;

int main() {
	string s = "Hello World!";
	cout <<  (s * toupper) << endl;
}
----------------------------------------------------------------------------

With SCC, equavalent which also shows output, would be much shorter: 

----------------------------------------------------------------------------
scc "str s = "Hello World!";  s * toupper'
HELLO WORLD!
----------------------------------------------------------------------------

1st line in above is what you type at your shell prompt.  2nd line is output.
SCC includes all standard libraries inlcudes; and it sends last
statement-expresion, if not terminated by semi-colon, to `std::cout`.  Typedef
`str` is shortcut for `std::string`, similarly `vint` (in examples that will
follow) is `std::vector<int>`.

SCC printer can print almost any STL objects (containers, tuples, etc)
directly.  Items in print operator (and last expression which will be printed)
are seperated by `,` not by `<<`. 

-----------------------------------------------------------------------------
scc 'auto r = range(0, 1, 0.1);  r, endl, r * sin'
{0, 0.1, 0.2, 0.3, 0.4, 0.5, 0.6, 0.7, 0.8, 0.9, 1}
 {0, 0.0998334, 0.198669, 0.29552, 0.389418, 0.479426, 0.564642, 0.644218, 0.717356, 0.783327, 0.841471}
-----------------------------------------------------------------------------

Print operator are `_` and `__`.  Longer one terminates output with `endl`.
With these, previous example would be:

-----------------------------------------------------------------------------
scc '__ range(0, 1, 0.1);  __ range(0, 1, 0.1) * sin;'
-----------------------------------------------------------------------------


This is all you need to know about SCC, you can read more on http://volnitsky.com/project/scc[SCC page].  


Range Operators
~~~~~~~~~~~~~~~

Ranges are generalization of STL containers.
STO defines operators to work with ranges (and STL containers). 
It have two groups of operators.  First is shortcuts for containers' member functions and simple
extensions. Second is more complex operations like
fold, reduce, filter and arbitrary transformation of ranges.

In table below are 1st group - simple shortcuts for container member functions.
Unlike STL member functions they usually return result of operation (so it can
be used in expressions).

----------------------------------------------------------------
+Rg			//  Rg.begin()
-Rg			//  Rg.end()
++Rg			//  Rg.front()
Rg++			//  Rg.back()
--Rg			//  Rg.pop_front()
Rg--			//  Rg.pop_back()

Rg << x			//  Rg.push_back(x)
x >> Rg			//  Rg.push_front(x)
Rg >> x			//  x = Rg.back(x);   Rg.pop_back();
x << Rg			//  x = Rg.front(x);  Rg.pop_front();
Rg1 << Rg2		//  copy(Rg2.begin(), Rg2.end(), back_inserter(Rg1));
Rg1 >> Rg2		//  copy(Rg1.rbegin(), Rg1.rend(), front_inserter(Rg2)); 

++Pair			//  Pair.first
Pair++			//  Pair.second

++Tuple			//  get\<0>(Tuple)
Tuple++			//  get<tuple_size<tuple<Types...> >::value-1>(Tuple)


Stack << x		//  Stack.push(x)
Stack++ 		//  Stack.top(x)
Stack >> x		//  x = Stack.top(x);  Stack.pop()
Stack-- 		//  Stack.pop()
		
Queue++ 		//  Queue.back(x)
++Queue 		//  Queue.front(x)
--Queue 		//  Queue.pop(x)
Queue << x		//  Queue.push(x)
x << Queue		//  x = Queue.front(x);  Queue.pop()

Rg = Rg2 		//  undelying contanainers can be of different type
Rg = x 			//  fill(Rg.begin(), Rg.end(), x)

// SEARCH

Rg / x			// find(+Rg, -Rg, x)
Rg % x			// find(+Rg, -Rg, x) != -Rg
Rg / Pred		// find_if(+Rg, -Rg, pred) 	
Rg % Pred		// find_if(+Rg, -Rg, pred) != -Rg
Rg / Rg			// search(+Rg, -Rg, +Rg, -Rg) 


// GENERIC ERASE

Rg - x			// erase all elements equal to x
Rg - pred		// erase all elements evaluated to 'true` 
Rg - Rg2		// erase subrange 
Rg - It			// erase at iterator

----------------------------------------------------------------



Ranges
------

_Ranges_ are numeric ranges,  iterator ranges,  expression ranges, STL
containers, C-arrays and C-strings.  STO defines C-strings as zero terminated
arrays of `char` (not `signed char` or `unsigned chars`).  Expression ranges
are result of range expression (fold/reduce/filter). 

Subset of Ranges are _STO Ranges_:  iterator ranges, expression ranges and numeric
ranges.  STO ranges do not contain data, they refer to an existing STL
container or generate its elements.  Particular type of the range often is not
important and it is result of range expression or `range()` convenience
function.


Numeric range
~~~~~~~~~~~~~

Numeric range is simple numeric sequence generator :

-----------------------------------
scc 'range(5)'
{0, 1, 2, 3, 4, 5}

scc 'range(1,5)'
{1, 2, 3, 4, 5}

scc 'range(1,5,0.5)'
{1, 1.5, 2, 2.5, 3, 3.5, 4, 4.5, 5}

scc 'range(10,0,-1.5)'
{10, 8.5, 7, 5.5, 4, 2.5, 1}
-----------------------------------

Iterator range
~~~~~~~~~~~~~~

Iterator range is simple wrapper for for a range defined by first and last iterator.

Assign `42` to elements `2..4` of vector `{0,1,2,3,4,5,6,7,8,9}`:

------------------------------------
scc 'vint V=range(0,9);   range(V/2, V/5) = 42;  V'
{0, 1, 42, 42, 42, 5, 6, 7, 8, 9}
------------------------------------

Expression `range(0,9)` constructs numeric range which initialize `V`.  
Expression `V/2` returns iterator to 1st element with value `2`.  Expression
`range(V/2,V/5)` constructs iterator range from pair of iterators.


Ranges can be assigned to another range even if they have different underlying
containers.  Here is simplest expression range, which shows that it just
a reference to underlying container:

------------------------------------------
scc  'vint V;  auto R=range(V);  R=range(0,9);  R, V'
{0, 1, 2, 3, 4, 5, 6, 7, 8, 9} {0, 1, 2, 3, 4, 5, 6, 7, 8, 9}
-------------------------------------------------


Operation with C-strings 
~~~~~~~~~~~~~~~~~~~~~~~~

We first assign a c-string, then append `"XYZ"` and then remove `"bc"` substring :

-----------------------------------------
scc 'char s[99];  range(s) = "abc";  (range(s) << "XYZ") - "bc"'
aXYZ
------------------------------------------

Note that we can not define overloaded operations if arguments are only POD types (like c-string).
+++C++ +++ do not allow this. This is a reason why we have to wrap `s` with `range()`. For binary
ops, we need to wrap at least one of operands in a class.

Same example, but for `str::string` (without range-wrapping):

-----------------------------------------
scc 'str s("abc");  (s << "XYZ") - "bc"'
aXYZ
------------------------------------------


Operators: Map, Reduce, Filter
----------------------------


Map/Transform
~~~~~~~~~~~~~

Operator `sto::operator* (Range,Functor)` is map/transform operator.

------------------------------------------
scc 'range("abc") * toupper'
ABC

scc 'vint V{-1,0,1};  V * abs'
{1, 0, 1}
------------------------------------------

In above, `toupper` is defined in `functor.h`,  `abs` is taken from `std::`.

Expression `V * abs` is equivalent to:

----------------------------------------------
std::transform(V.begin(), V.end(), V.begin(), std::abs<int>)'
----------------------------------------------


Reduce/Fold
~~~~~~~~~~~

Operator `sto::operator|| (Range,Functor)` is fold operator.

------------------------------------------
scc 'vint V{1,2,3};  V || plus<int>()'
6

scc 'vint V{1,2,3};  V || add'  	// add -  STO shortcut for std::plus<int>()
6

scc 'vint V{1,2,3};  V || mul'		// mul -  STO shortcut for std::multiplyes<int>()
6

scc 'vint V{1,2,3};  V || min'		// uses std::min
1
------------------------------------------

Expression  `V || min` is equivalent to:

-------------------------------------------------
std::accumulate (
	std::next(V.begin()),
	V.end(),
	V.front(),
	static_cast<const int& (*)(const int&, const int&)>(std::min<int>)
);
------------------------------------------------


Find (brute force algorithm) maximum of  `cos(x)` for `8 < x < 9`:

------------------------------------------
scc 'range(8, 9, 0.01) * cos  || max'
-0.1455
------------------------------------------


Pipe
~~~~

Pipe operator have much more freedom on what it can do with range. It can filter out,
add, reorder and convert to different type. It has overloads for different right-hand-side objects.


Pipe-filter
^^^^^^^^^^^

Pipe-filter are defined with `operators|(Range, Predicate)` and `operator|(Range, range_elem_type)`. 

Predicate is functor with signature `bool(*)(range_elem_type)`. If such is used
with pipe operator, all elements which evaluate to `false` with predicate - are
filtered out:

------------------------------------------
scc 'range("abc-123") | isdigit'
123
-----------------------------------------

Filter and transform:

-----------------------------------------
scc '(range("abc-123, xyz/") | isalnum) * toupper'
ABC123XYZ
------------------------------------------

Hide digits:

---------------------------------------------------------------------
scc 'str S="John Q Public  (650)1234567";  S|isdigit=*"X";  S'
John Q Public  (XXX)XXXXXXX
-----------------------------------------------------------------

Expression `S | isdigit`, produce a filtered range,  where `isdigit` is
predicate for filtering.  This is lazy-evaluated, it does not creates
temporary container and should be as efficient as hand written for-loop.
Expression `*"X"` is the same thing as `'X'` (as work around for Bash/+++C++ +++
quotes conflict).


Filter `operator|(Range, range_elem_type)` selects only elements which are equal to second argument:

Replace 2 with 42:

---------------------------------------------------------------------
scc 'vint V=range(5);  V | 2 = 42; V'
{0, 1, 42, 3, 4, 5}
-----------------------------------------------------------------


Pipe-stl-algorithm
^^^^^^^^^^^^^^^^^^

Simple `operator|(Range, void(*)(It1,It2))` matches STL algorithm which have 2 arguments iterators:

-----------------------------------------------------------------
scc 'vint{3,1,2,3} | sort | unique | reverse'
{3, 2, 1}
-----------------------------------------------------------------

Unlike STO ranges, this is not lazy evaluated and equivalent to:

-----------------------------------------------------------------
scc 'vint V{3,1,2,3};  sort(+V,-V);  auto e=unique(+V, -V);  V.erase(e,-V);  reverse(+V,-V);  V'
{3, 2, 1}
-----------------------------------------------------------------




Available Functors
~~~~~~~~~~~~~~~~~~

Functors are function object, lambdas and
plain functions. Unfortunately many functions inherited from C are not usable
with STO.  STO relies on fact that functor have argument of the same type as
range element type.  But for examples `ctype.h` functions, which work with
c-strings, have not `char` but `int` as parameter and they can be defined as macros.  And
what makes it even worse,  they are randomly injected into default namespace by +++ LIBSTDC++ +++.
As workaround STO put equivalent functions with correct signatures into `sto`
namespace.


Simple IO
---------

Bar-print
~~~~~~~~~

Instead of `std::cout` printing, in SCC you can use so called **bar-print**.
Below are bar-print statements with equivalent code in comments:

---------------------------------------------------------------
_  x;                  //  cout << x;
__ x;                  //  cout << x << endl;
__ x, y;               //  cout << x << " " << y << endl;
-------------------------------------------------------------------------

On last line `" "` will not be printed if  `x` or `y` are strings.

On exit, SCC also checks if last output was unterminated  with linefead.  If
true, it will add a linefead.  Let say if last statement was `cout << x;`, then SCC
will add `cout << endl;` on exit.


OI - Generic ostream_iterator
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

Standard library includes `std::ostream_iterator`. Unlike `std::cout` it
accepts only one specific type (specified at construction time) and it is not
pre-defined object.   So to use it with STL algorithms, you need
call its quite verbose constructor.

Let say we have `vector<int> V;` and `set<string> S;` and we want
to print these.  With `std::ostream_iterator`:

------------------------------------------------------------------
copy(V.begin(), V.end(), ostream_iterator<int>   (cout, " "));
copy(S.begin(), S.end(), ostream_iterator<string>(cout, " "));
-------------------------------------------------------------------

Include `io.h` defines `oi` object - SCC replacement for `ostream_iterator`, which can work with any type and
is pre-defined.  With `oi`, above example will be:

-------------------------------------------------------------------
copy(V.begin(), V.end(), oi);
copy(S.begin(), S.end(), oi);
-------------------------------------------------------------------

Same using range operators, more about these later: 

-------------------------------------------------------------------
copy(+V, -V, oi);
copy(+S, -S, oi);
-------------------------------------------------------------------

Also assigning a container to `oi` is equivalent to doing
`std::copy`, so still shorter:

-------------------------------------------------------------------
oi = V;
oi = S;
-------------------------------------------------------------------

STL Containers input / output
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

Any STL container can be also printed without `oi`.  You can just send it to
`std::cout` or bar-print it.

In below example `__ C;` can be replaced with `cout << C;`. Equivalent code and
output is shown in comments:

--------------------------------------------------------------------
vint            C {1,2,3};        __ C;	   //  vector<int> C{1,2,3};
 					   //  cout << "{"; 
					   //  for(auto it=C.begin(); it!=C.end()-1; it++)
					   //       cout << *it << ", ";
					   //  if(!C.empty()) cout << C.back(); 
					   //  cout << "}\n";
					   //  prints: {1, 2, 3}
					
int             C[] {1,2,3};       __ C;   //  {1,2,3} 
array<int,3>    C {1,2,3};         __ C;   //  {1,2,3}
tuple<int,int>  C {1,2};           __ C;   //  ⟨1, 2⟩ 
map<int,int>    C {{1,2},{3,4}};   __ C;   //  {⟨1,2⟩, ⟨3,4⟩} 
vector<vint>	C {{1,2},{3,4}};   __ C;   //  {{1, 2}, {3, 4}}
-------------------------------------------------------------------

Same for input:

----------------------------------------------------------------------
echo 1 2    | scc 'vint            C;     cin >> C;   C'	//  {1,2}
echo 1 2    | scc 'int             C[2];  cin >> C;   C'	//  {1,2}
echo 1 2    | scc 'tuple<int,int>  C;     cin >> C;   C'	//  ⟨1,2⟩
echo 1 2    | scc 'array<int,2>    C;     cin >> C;   C'	//  {1,2}
echo 1 2    | scc 'set<int>        C;     cin >> C;   C'	//  {1,2}
echo 1 2 3 4| scc 'map<int,int>    C;     cin >> C;   C'	//  {⟨1,2⟩, ⟨3,4⟩}
----------------------------------------------------------------------

//////////////
echo 1 2    | scc 'int             C[2];  cin >> C;   C'	//  {1, 2}
echo 1 2    | scc 'array<int,2>    C;     cin >> C;   C'	//  {1, 2}
echo 1 2.2  | scc 'pair<int,float> p;     cin >> p;   p'	//  ⟨1,2.2⟩
echo 1 2    | scc 'tuple<int,int>  C;     cin >> C;   C'	//  ⟨1, 2⟩
////////////

If a container have non-zero length, then the corresponding number of elements will be
read.  If container is empty then input will be EOF-terminated.

Object IN
~~~~~~~~~

Pre-defined object `in` can be used as value in expression which is read from
`std::cin`.

--------------------------------------------------------------------
int i(in);			//  int i;  cin >> i;	
float x = 1.1 + float(in);	//  float y;  cin >> y;   float x = 1.1 + y;
--------------------------------------------------------------

WARNING: Object `in` does not check for EOF. Use only in
context where you can ignore or do not expect EOF.

To input a container:

--------------------------------------------------------------------
vint V = in(10);
vint W = in;		// Till EOF.  Note:  we can not use:  vint W(in);
--------------------------------------------------------------------

Here is example of +++ C++ +++ vs SCC input where we need to read a number and than
corresponding number of container elements:

--------------------------------------------------------------------
int N; 
cin >> N;
vector<int> V(N); 
for(int i=0; i<N; i++) 
	cin >> V[i];
--------------------------------------------------------------------

With object `in`:

--------------------------------------------------------------------
vint V = in(in);
--------------------------------------------------------------------


IO.H - Standalone Use
~~~~~~~~~~~~~~~~~~~~~

File `io.h` can be used as standalone, independent include. 

--------------------------------------------
#include <io.h>
int main() {
	__ "hello world";
}
-------------------------------------------

Includes `simple.h`, `cj.h` and `stl.h` can also be used independently.




Status 
------

STO uses +++ C++11 +++ extensively.  Because no complier yet
implemented +++ C++11 +++ fully and each implemented different subset, 
STO very picky about compiler.  See GCC, CLANG sections below. 


GCC 
~~~
 
SCC was mostly tested with GCC-4.7.2/4.8-pre-release and CLANG-3.2-pre-release.
If you need to use SCC with older compiler - use commit tagged as `v0.1`.

In course of development several GCC bugs were encountered.
Luckily, GCC team is pretty quick to fix things after you will file a but report.

- httpx://gcc.gnu.org/bugzilla/show_bug.cgi?id=51989[Bug 51989 (fixed) -- deque iterator, void with templates]
- httpx://gcc.gnu.org/bugzilla/show_bug.cgi?id=54425[Bug 54425 -- Rvalue/Lvalue overload resolution of templated]
- httpx://gcc.gnu.org/bugzilla/show_bug.cgi?id=54111[Bug 54111 -- function return type template deduction]
- httpx://gcc.gnu.org/bugzilla/show_bug.cgi?id=54538[Bug 54538 (fixed) -- (4.8 Regression) Getting assembler messages when compiling]
- httpx://gcc.gnu.org/bugzilla/show_bug.cgi?id=53858[Bug 53858 (fixed)  -- (4.8 Regression) template aliases used in template parameters default expression]
- httpx://gcc.gnu.org/bugzilla/show_bug.cgi?id=54648[Bug 54648 -- constexpr function rejected as non const]
- httpx://gcc.gnu.org/bugzilla/show_bug.cgi?id=54859[Bug 54859 -- constexpr in template aliase rejected as non-constant]


CLANG 
~~~~~

CLANG-3.2 is fully supported. 


Corresponding CLANG bugs:

- httpx://http://llvm.org/bugs/show_bug.cgi?id=11851[Bug 11851 - constexpr bug ]
- httpx://http://llvm.org/bugs/show_bug.cgi?id=13970[Bug 13970 - constexpr function rejected as non const(dup of 11851)]







////////////////

== Refs 

RANGES
	http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2012/n3350.html

	random iterator
		Take arbitrary integer number P that GCD(P, N) == 1 where GCD(P, N) is greatest common divisor of P and N (e.g. GCD(70, 42) == 14, GCD(24, 35) == 1).
		Get sequence K[i] ::= (P * i) mod N + 1, i from 1 to N
		It's proven that sequence K[i] enumerates all numbers between 1 and N with no repeats (actually K[N + 1] == K[1] but that is not a problem because we need only first N numbers).
		If you can efficiently generate such numbers P with uniform distribution (e.g. with a good random function) with using Euclidean algorithm to calculate GCD in O(log(N)) complexity you'll get what you want.

	linq -- http://stackoverflow.com/questions/8910045/template-argument-deduction

MAP
	TRIE
		http://login2win.blogspot.com/2011/06/c-tries.html

	HASH_MAP
		http://msinilo.pl/blog/?p=170
			fastest -- http://code.google.com/p/rdestl/
			http://attractivechaos.wordpress.com/2008/08/28/comparison-of-hash-table-libraries/
			http://attractivechaos.wordpress.com/2008/09/12/the-google-hash-table-library/
			http://www.augustana.ca/~mohrj/courses/1999.fall/csc210/lecture_notes/hashing.html
			http://svn.python.org/view/python/trunk/Objects/dictnotes.txt?view=markup&pathrev=53782
	http://stackoverflow.com/questions/11614106/is-gcc-stdunordered-map-implementation-slow-if-so-why

STL
	map adapter: https://github.com/krig/k11/blob/master/src/tests/iter.cpp

SIMILAR PROJECTS

	http://yapb-soc.blogspot.com/2012/10/fmap-in-c-part-1.html

vim: ft=asciidoc
///////////////////////////////////
