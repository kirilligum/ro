include::/tmp/t.ad[]

+++ <small> +++

* Repo: httpx://github.com/lvv/sto[GitHub],  httpx://bitbucket.org/lvv/sto[BitBucket] +
* Requires:  +++ C++11 +++   compiler.  Tested with GCC-4.7.2, GCC-4.8(pre release), CLANG-3.2(pre release) +
* License:  httpx://en.wikipedia.org/wiki/Boost_Software_License[Boost Software License]

+++ </small> +++


SCC
---

STO was originally part of SCC (+++ C++ +++ snippet evaluator at shell prompt).
It does not depands on SCC but we will use it in out examples, so we need to
tell you about SCC first.  Without SCC, minimal and complete example for 
`operator*(Range,Functor)` would be:

----------------------------------------------------------------------------
#include <iostream>
#include <string>
	using namespace std;

#include <sto/sto.h>
	using namespace sto;

int main() {
	string s = "Hello World!";
	cout <<  (s * toupper) << endl;
}
----------------------------------------------------------------------------

With SCC, equavalent which also shows output, would be much shorter: 

----------------------------------------------------------------------------
scc "str s = "Hello World!";  s * toupper'
HELLO WORLD!
----------------------------------------------------------------------------

1st line in above is what you type at your shell prompt.  2nd line is output.
SCC includes all standard libraries inlcudes; and it sends last
statement-expresion, if not terminated by semi-colon, to `std::cout`.  Typedef
`str` is shortcut for `std::string`, similarly `vint` (in examples that will
follow) is `std::vector<int>`.

SCC printer can print almost any STL containers (containers, tuples, etc)
directly.  Items in print operator are seperated by `,` not by `<<`. 

-----------------------------------------------------------------------------
scc 'auto r = range(0, 1, 0.1);  r, endl, r * sin'
{0, 0.1, 0.2, 0.3, 0.4, 0.5, 0.6, 0.7, 0.8, 0.9, 1}
 {0, 0.0998334, 0.198669, 0.29552, 0.389418, 0.479426, 0.564642, 0.644218, 0.717356, 0.783327, 0.841471}
-----------------------------------------------------------------------------

Print operator are `_` and `__`.  Longer one terminates output with `endl`.
With these, previous example would be:


-----------------------------------------------------------------------------
scc '__ range(0, 1, 0.1);  __ range(0, 1, 0.1) * sin;'
-----------------------------------------------------------------------------


This is all you need to know about SCC, you can read more on http://volnitsky.com/project/scc[SCC page].  


Range Operators
~~~~~~~~~~~~~~~

Ranges are generalization of STL containers.
STO defines operators to work with ranges (and STL containers). 
It have two groups of operations.  First is shortcuts for containers' member functions and simple
extensions. Second is more complex operations like
fold, reduce, filter and arbitrary transformation of ranges.

In table below are 1st group - simple shortcuts for container member functions.
Unlike STL member functions they usually return result of operation (so it can be used in expressions).

----------------------------------------------------------------
+C			//  C.begin()
-C			//  C.end()
++C			//  C.front()
C++			//  C.back()
--C			//  C.pop_front()
C--			//  C.pop_back()

C << x			//  C.push_back(x)
x >> C			//  C.push_front(x)
C >> x			//  x = C.back(x);   C.pop_back();
x << C			//  x = C.front(x);  C.pop_front();
C1 << C2		//  copy(C2.begin(), C2.end(), back_inserter(C1));
C1 >> C2		//  copy(C1.rbegin(), C1.rend(), front_inserter(C2)); 

++Pair			//  Pair.first
Pair++			//  Pair.second

++Tuple			//  get\<0>(Tuple)
Tuple++			//  get<tuple_size<tuple<Types...> >::value-1>(Tuple)


Stack << x		//  Stack.push(x)
Stack++ 		//  Stack.top(x)
Stack >> x		//  x = Stack.top(x);  Stack.pop()
Stack-- 		//  Stack.pop()
		
Queue++ 		//  Queue.back(x)
++Queue 		//  Queue.front(x)
--Queue 		//  Queue.pop(x)
Queue << x		//  Queue.push(x)
x << Queue		//  x = Queue.front(x);  Queue.pop()
----------------------------------------------------------------


Ranges
~~~~~~

Ranges are numeric ranges,  iterator ranges,  expression ranges, STL
containers, C-arrays and C-strings.  STO defines C-strings as zero terminated
arrays of `char` (not `signed char` or `unsigned chars`).  Expression ranges
are result of various range expression (like fold/reduce/filter).  Subset of
Ranges are STO Ranges:  iterator ranges, expresion ranges and numeric ranges.
STO ranges do not contain data, they refer to an existing STL container or
generate its elements.


Numeric range is simple numeric sequence generator :

-----------------------------------
scc 'range(5)'
{0, 1, 2, 3, 4, 5}

scc 'range(1,5)'
{1, 2, 3, 4, 5}

scc 'range(1,5,0.5)'
{1, 1.5, 2, 2.5, 3, 3.5, 4, 4.5, 5}

scc 'range(10,0,-1.5)'
{10, 8.5, 7, 5.5, 4, 2.5, 1}
-----------------------------------

Iterator range is simple wrapper for for a range defined be first and last iterator.
Below we will assign 42 to elements `2..4` of vector `{0,1,2,3,4,5,6,7,8,9}`:

------------------------------------
scc 'vint v;  v << range(0,9);   range(v/2, v/5) = 42;  v'
{0, 1, 42, 42, 42, 5, 6, 7, 8, 9}
------------------------------------

Expression `range(0,9)` construct numeric range which initialize `v`.  
Expression `v/2` returns iterator to 1st element with value `2`.  Expression
`range(v/2,v/5)` construct iterator range from pair of iterators.

Ranges can be assigned to another range even if they have different underlying
containers.  Here is simplest expression range, which shows that it just
a reference to underlying container:

------------------------------------------
scc  'vint v;  auto r=range(v);  r = range(0,9);  r, v'
{0, 1, 2, 3, 4, 5, 6, 7, 8, 9} {0, 1, 2, 3, 4, 5, 6, 7, 8, 9}
-------------------------------------------------


Operation with C-strings. We first assign a c-string and then append another:

-----------------------------------------
scc 'char S[99];  range(S) = "abc";  __ S;   range(S) << " XYZ"'
abc
abc XYZ
------------------------------------------

Note that we can not define overloaded operations for POD types (like c-string).
+++C++ +++ do not allow this. This is a reason why we have to wrap `S` with `range()`. For binary
ops, we need to wrap at least one of operands in a class.

Same example, but for `str::string` (without range-wrapping):

-----------------------------------------
scc 'str s;  s = "abc";  __ s;   s << " XYZ"'
abc
abc XYZ
------------------------------------------


Pipe, Map, Reduce
-----------------


Map/Transform
~~~~~~~~~~~~~

Operator `sto::operator* (Range,Functor)` is equivalent to `std::transform`:

------------------------------------------
scc 'range("abc") * toupper'
ABC

scc 'vint V{-1,0,1};  V * abs'
{1, 0, 1}
------------------------------------------

In above, `toupper` is defined in `functor.h`,  `abs` is taken from `std::`.

Expression `V * abs` is equivalent to:

----------------------------------------------
std::transform(V.begin(), V.end(), V.begin(), std::abs<int>)'
----------------------------------------------


Reduce/Fold
~~~~~~~~~~~

Operator `sto::operator|| (Range,Functor)` is equivalent to `std::accumulate`

------------------------------------------
scc 'vint V{1,2,3};  V || plus<int>()'
6

scc 'vint V{1,2,3};  V || add'  	// with STO shortcut for std::plus<int>()
6

scc 'vint V{1,2,3};  V || mul'		// with shortcut for std::multiplyes<int>()
6

scc 'vint V{1,2,3};  V || min'		// uses std::min
1
------------------------------------------

Expression  `V || min` is equivalent to:

-------------------------------------------------
std::accumulate (
	std::next(V.begin()),
	V.end(),
	V.front(),
	static_cast<const int& (*)(const int&, const int&)>(std::min<int>)
);
------------------------------------------------


Find (brute force algorithm) maximum of  `cos(x)` for `8 < x < 9`:

------------------------------------------
scc 'range(8, 9, 0.01) * cos  || max'
-0.1455
------------------------------------------


Pipe
~~~~

Pipe operator have much more freedom on what it can do with range. It can filter out,
add, reorder and convert to different type. It is overloaded for different right-hand-side objects.


Pipe-filter
^^^^^^^^^^^

Predicate is functor with signature `bool(*)(range_elem_type)`. If such is used
with pipe operator, all elements which evaluate to `false` with predicate - are
filtered out:

------------------------------------------
scc 'range("abc-123") | isdigit'
123

scc '(range("abc-123, xyz/") | isalnum) * toupper'
ABC123XYZ
------------------------------------------

Range expression are lazy evaluated - value is computed only when needed. 
In above examples there was no dynamic memory or stack  space allocation. 
It should be as efficient as manually written `for` loop.





Here we use `std::string` assignment operator to append, and  STO `<<` op to append.

---------------------------------------------------------------------
scc 'str S="John Q Public  (650)1234567";  S|isdigit=*"X";  S'
John Q Public  (XXX)XXXXXXX
-----------------------------------------------------------------

Expression `S | isdigit`, produce a filtered range,  where `isdigit` is
predicate for filtering.  This is lazy-evaluated, it does not creates
temporary container and should be efficient as hand written for-loop.
Expression `*"X"` is the same thing as `'X'` (as work around for Bash/+++C++ +++
qoutes conflict).


--- THIS SECTION IS INCOMPLETE ---

///////////////////////////////////////////////
Rn / x		-> it		// find(+Ct, -Ct, x)
Rn % x		-> bool		// find(+Ct, -Ct, x) != -Ct
Rn / f		-> it
Rn % f		-> bool		// find(+Ct, -Ct, x) != -Ct
Rn / Rn		-> Rn		// search(+Ct, -Ct, +Rg, -Rg) 
Rn - it 			// Ct.eraze(it);
Rn - Rn				// erase
Rn = Rn2 			// with conversion

src >> ct-dest
ct-dest << src

Rn  * f(x)	-> Rn		// transform	(map)
Rn || f(x,y)	-> T 		// accumulate    (fold)
Rn  | filter-t	-> Rn 		// filter

////////////////////////////////////////////////

////////////////////////////////////////////////////////
/*	 		Ct	string	A	c-str
*	-------------+-------------------------------
*	+Ct		+	+	-	-
*	-Ct		+	+	-	-
*	~Ct		+	+	-	-
*	!Ct		+	+	-	-
*	++Ct		+	+	-	-
*	Ct++		+	+	-	-
*	Ct << x		+	+	-	-
*/
/////////////////////////////////////////////////////////

Available Functors
~~~~~~~~~~~~~~~~~~

Functors are function object, lambdas and
plain functions. Unfortunately many functions inherited from C are not usable
with STO.  STO relies on fact that functor have argument of the same type as
range element type.  But for examples `ctype.h` functions, which work with
c-strings, have not `char` but `int` as parameter and they can be defined as macros.  And
what makes it even worse,  they are randomly injected into default namespace by +++ LIBSTDC++ +++.
As workaround STO put equivalent functions with correct signatures into `sto`
namespace.


Simple IO
---------

Bar-print
~~~~~~~~~

Instead of `std::cout` printing, in SCC you can use so called **bar-print**.
Below are bar-print statements with equivalent code in comments:

---------------------------------------------------------------
_  x;                  //  cout << x;
__ x;                  //  cout << x << endl;
__ x, y;               //  cout << x << " " << y << endl;
-------------------------------------------------------------------------

On last line `" "` will not be printed if  `x` or `y` are strings.

On exit, SCC also checks if last output was unterminated  with linefead.  If
true, it will add a linefead.  Let say if last statement was `cout << x;`, then SCC
will add `cout << endl;` on exit.


OI - Generic ostream_iterator
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

Standard library includes `std::ostream_iterator`. Unlike `std::cout` it
accepts only one specific type (specified at construction time) and it is not
pre-defined object.   So to use it with STL algorithms, you need
call its quite verbose constructor.

Let say we have `vector<int> V;` and `set<string> S;` and we want
to print these.  With `std::ostream_iterator`:

------------------------------------------------------------------
copy(V.begin(), V.end(), ostream_iterator<int>   (cout, " "));
copy(S.begin(), S.end(), ostream_iterator<string>(cout, " "));
-------------------------------------------------------------------

Include `io.h` defines `oi` object - SCC replacement for `ostream_iterator`, which can work with any type and
is pre-defined.  With `oi`, above example will be:

-------------------------------------------------------------------
copy(V.begin(), V.end(), oi);
copy(S.begin(), S.end(), oi);
-------------------------------------------------------------------

Same using range operators, more about these later: 

-------------------------------------------------------------------
copy(+V, -V, oi);
copy(+S, -S, oi);
-------------------------------------------------------------------

Also assigning a container to `oi` is equivalent to doing
`std::copy`, so still shorter:

-------------------------------------------------------------------
oi = V;
oi = S;
-------------------------------------------------------------------

STL Containers input / output
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

Any STL container can be also printed without `oi`.  You can just send it to
`std::cout` or bar-print it.

In below example `__ C;` can be replaced with `cout << C;`. Equivalent code and
output is shown in comments:

--------------------------------------------------------------------
vint            C {1,2,3};        __ C;	   //  vector<int> C{1,2,3};
 					   //  cout << "{"; 
					   //  for(auto it=C.begin(); it!=C.end()-1; it++)
					   //       cout << *it << ", ";
					   //  if(!C.empty()) cout << C.back(); 
					   //  cout << "}\n";
					   //  prints: {1, 2, 3}
					
int             C[] {1,2,3};       __ C;   //  {1,2,3} 
array<int,3>    C {1,2,3};         __ C;   //  {1,2,3}
tuple<int,int>  C {1,2};           __ C;   //  ⟨1, 2⟩ 
map<int,int>    C {{1,2},{3,4}};   __ C;   //  {⟨1,2⟩, ⟨3,4⟩} 
vector<vint>	C {{1,2},{3,4}};   __ C;   //  {{1, 2}, {3, 4}}
-------------------------------------------------------------------

Same for input:

----------------------------------------------------------------------
echo 1 2    | scc 'vint            C;     cin >> C;   C'	//  {1,2}
echo 1 2    | scc 'int             C[2];  cin >> C;   C'	//  {1,2}
echo 1 2    | scc 'tuple<int,int>  C;     cin >> C;   C'	//  ⟨1,2⟩
echo 1 2    | scc 'array<int,2>    C;     cin >> C;   C'	//  {1,2}
echo 1 2    | scc 'set<int>        C;     cin >> C;   C'	//  {1,2}
echo 1 2 3 4| scc 'map<int,int>    C;     cin >> C;   C'	//  {⟨1,2⟩, ⟨3,4⟩}
----------------------------------------------------------------------

//////////////
echo 1 2    | scc 'int             C[2];  cin >> C;   C'	//  {1, 2}
echo 1 2    | scc 'array<int,2>    C;     cin >> C;   C'	//  {1, 2}
echo 1 2.2  | scc 'pair<int,float> p;     cin >> p;   p'	//  ⟨1,2.2⟩
echo 1 2    | scc 'tuple<int,int>  C;     cin >> C;   C'	//  ⟨1, 2⟩
////////////

If a container have non-zero length, then the corresponding number of elements will be
read.  If container is empty then input will be EOF-terminated.

Object IN
~~~~~~~~~

Pre-defined object `in` can be used as value in expression which is read from
`std::cin`.

--------------------------------------------------------------------
int i(in);			//  int i;  cin >> i;	
float x = 1.1 + float(in);	//  float y;  cin >> y;   float x = 1.1 + y;
--------------------------------------------------------------

WARNING: Object `in` does not check for EOF. Use only in
context where you can ignore or do not expect EOF.

To input a container:

--------------------------------------------------------------------
vint V = in(10);
vint W = in;		// Till EOF.  Note:  we can not use:  vint W(in);
--------------------------------------------------------------------

Here is example of +++ C++ +++ vs SCC input where we need to read a number and than
corresponding number of container elements:

--------------------------------------------------------------------
int N; 
cin >> N;
vector<int> V(N); 
for(int i=0; i<N; i++) 
	cin >> V[i];
--------------------------------------------------------------------

With object `in`:

--------------------------------------------------------------------
vint V = in(in);
--------------------------------------------------------------------


IO.H - Standalone Use
~~~~~~~~~~~~~~~~~~~~~

File `io.h` can be used as standalone, independent include. 

--------------------------------------------
#include <io.h>
int main() {
	__ "hello world";
}
-------------------------------------------

Includes `simple.h`, `cj.h` and `stl.h` can also be used independently.




Status 
------

STO uses +++ C++11 +++ extensively.  Because no complier yet
implemented +++ C++11 +++ fully and each implemented different subset, 
STO very picky about compiler.  See GCC, CLANG sections below. 


GCC 
~~~
 
SCC was mostly tested with GCC-4.7.2/4.8-pre-release and CLANG-3.2-pre-release.
If you need to use SCC with older compiler - use commit tagged as `v0.1`.

In course of development several GCC bugs were encountered.
Luckily, GCC team is pretty quick to fix things after you will file a but report.

- httpx://gcc.gnu.org/bugzilla/show_bug.cgi?id=51989[Bug 51989 (fixed) -- deque iterator, void with templates]
- httpx://gcc.gnu.org/bugzilla/show_bug.cgi?id=54425[Bug 54425 -- Rvalue/Lvalue overload resolution of templated]
- httpx://gcc.gnu.org/bugzilla/show_bug.cgi?id=54111[Bug 54111 -- function return type template deduction]
- httpx://gcc.gnu.org/bugzilla/show_bug.cgi?id=54538[Bug 54538 (fixed) -- (4.8 Regression) Getting assembler messages when compiling]
- httpx://gcc.gnu.org/bugzilla/show_bug.cgi?id=53858[Bug 53858 (fixed)  -- (4.8 Regression) template aliases used in template parameters default expression]
- httpx://gcc.gnu.org/bugzilla/show_bug.cgi?id=54648[Bug 54648 -- constexpr function rejected as non const]
- httpx://gcc.gnu.org/bugzilla/show_bug.cgi?id=54859[Bug 54859 -- constexpr in template aliase rejected as non-constant]


CLANG 
~~~~~

CLANG-3.2 is fully supported. 


Corresponding CLANG bugs:

- httpx://http://llvm.org/bugs/show_bug.cgi?id=11851[Bug 11851 - constexpr bug ]
- httpx://http://llvm.org/bugs/show_bug.cgi?id=13970[Bug 13970 - constexpr function rejected as non const(dup of 11851)]







////////////////

== Refs 

RANGES
	http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2012/n3350.html

	random iterator
		Take arbitrary integer number P that GCD(P, N) == 1 where GCD(P, N) is greatest common divisor of P and N (e.g. GCD(70, 42) == 14, GCD(24, 35) == 1).
		Get sequence K[i] ::= (P * i) mod N + 1, i from 1 to N
		It's proven that sequence K[i] enumerates all numbers between 1 and N with no repeats (actually K[N + 1] == K[1] but that is not a problem because we need only first N numbers).
		If you can efficiently generate such numbers P with uniform distribution (e.g. with a good random function) with using Euclidean algorithm to calculate GCD in O(log(N)) complexity you'll get what you want.

	linq -- http://stackoverflow.com/questions/8910045/template-argument-deduction

MAP
	TRIE
		http://login2win.blogspot.com/2011/06/c-tries.html

	HASH_MAP
		http://msinilo.pl/blog/?p=170
			fastest -- http://code.google.com/p/rdestl/
			http://attractivechaos.wordpress.com/2008/08/28/comparison-of-hash-table-libraries/
			http://attractivechaos.wordpress.com/2008/09/12/the-google-hash-table-library/
			http://www.augustana.ca/~mohrj/courses/1999.fall/csc210/lecture_notes/hashing.html
			http://svn.python.org/view/python/trunk/Objects/dictnotes.txt?view=markup&pathrev=53782
	http://stackoverflow.com/questions/11614106/is-gcc-stdunordered-map-implementation-slow-if-so-why

STL
	map adapter: https://github.com/krig/k11/blob/master/src/tests/iter.cpp

SIMILAR PROJECTS

	http://yapb-soc.blogspot.com/2012/10/fmap-in-c-part-1.html

vim: ft=asciidoc
///////////////////////////////////
